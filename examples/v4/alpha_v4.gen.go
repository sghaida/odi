// Code generated by (di v2); DO NOT EDIT.
// Spec: specs/alpha.inject.json
// Spec-SHA256: afd262a9627a67551a443862be272716c420f807fa22888c4b36cbe77bd6af93

package v4

import (
	"context"
	"fmt"
	di "github.com/sghaida/odi/di"
	config "github.com/sghaida/odi/examples/v4/config"
	"strings"
)

// AlphaV4InjectPolicyOnOverwrite controls behavior when a required dep is injected twice.
// NOTE: generated as a var to allow unit tests to cover all branches.
var AlphaV4InjectPolicyOnOverwrite = "error"

type AlphaV4 struct {
	cfg config.Config
	svc *Alpha

	injected map[string]bool

	// Optional wiring diagnostics (best-effort)
	optionalResolved map[string]string
	optionalMissing  map[string]string
}

// NewAlphaV4 creates a new builder/facade.
// You must call Build()/BuildWith()/MustBuild() before calling business methods.
func NewAlphaV4(cfg config.Config) *AlphaV4 {
	return &AlphaV4{
		cfg:              cfg,
		svc:              NewAlpha(cfg),
		injected:         map[string]bool{},
		optionalResolved: map[string]string{},
		optionalMissing:  map[string]string{},
	}
}

// Clone copies the builder with the current injected state.
// Useful for tests and branching wiring paths.
func (b *AlphaV4) Clone() *AlphaV4 {
	nb := &AlphaV4{
		cfg:              b.cfg,
		svc:              b.svc,
		injected:         map[string]bool{},
		optionalResolved: map[string]string{},
		optionalMissing:  map[string]string{},
	}
	for k, v := range b.injected {
		nb.injected[k] = v
	}
	for k, v := range b.optionalResolved {
		nb.optionalResolved[k] = v
	}
	for k, v := range b.optionalMissing {
		nb.optionalMissing[k] = v
	}
	return nb
}

// Reset discards injected bookkeeping and recreates the underlying implementation.
func (b *AlphaV4) Reset() *AlphaV4 {
	b.svc = NewAlpha(b.cfg)
	b.injected = map[string]bool{}
	b.optionalResolved = map[string]string{}
	b.optionalMissing = map[string]string{}
	return b
}

// UnsafeImpl returns the underlying implementation pointer for composition root wiring.
// It must NOT be used to call business methods before Build()/MustBuild().
func (b *AlphaV4) UnsafeImpl() *Alpha { return b.svc }

// Inject allows custom wiring for advanced usage.
// Prefer InjectX methods for required deps.
func (b *AlphaV4) Inject(fn func(*Alpha)) *AlphaV4 {
	if fn != nil {
		fn(b.svc)
	}
	return b
}

// TryInjectBeta injects the required dependency Beta.
// Unlike InjectBeta, it returns an error instead of panicking.
func (b *AlphaV4) TryInjectBeta(dep *Beta) (*AlphaV4, error) {
	switch AlphaV4InjectPolicyOnOverwrite {
	case "error":
		if b.injected["Beta"] {
			return nil, fmt.Errorf("AlphaV4: duplicate inject Beta")
		}
	case "ignore":
		if b.injected["Beta"] {
			return b, nil
		}
	case "overwrite":
		// allow overwriting
	default:
		return nil, fmt.Errorf("AlphaV4: invalid injectPolicy.onOverwrite=%s", AlphaV4InjectPolicyOnOverwrite)
	}
	b.svc.beta = dep
	b.injected["Beta"] = true
	return b, nil
}

// InjectBeta injects the required dependency Beta and panics on policy violations.
// Prefer TryInjectBeta for safer wiring in tests.
func (b *AlphaV4) InjectBeta(dep *Beta) *AlphaV4 {
	nb, err := b.TryInjectBeta(dep)
	if err != nil {
		panic(err)
	}
	return nb
}

// Missing returns the list of missing required dependency names at this moment.
// This is useful for debug UX before calling Build().
func (b *AlphaV4) Missing() []string {
	missing := []string{}
	if b.svc.beta == nil {
		missing = append(missing, "Beta")
	}
	return missing
}

// Explain returns a human-friendly summary of the wiring state.
func (b *AlphaV4) Explain() string {
	var sb strings.Builder
	m := b.Missing()
	if len(m) == 0 {
		sb.WriteString("required: complete\n")
	} else {
		sb.WriteString(fmt.Sprintf("required: missing=%v\n", m))
	}
	return sb.String()
}

func (b *AlphaV4) Build() (*Alpha, error) {
	return b.buildScoped("Build", nil)
}

// NOTE: Registry.Resolve must be (val any, ok bool, err error)
func (b *AlphaV4) BuildWith(reg di.Registry) (*Alpha, error) {

	return b.buildScoped("BuildWith", nil)
}

func (b *AlphaV4) MustBuild() *Alpha {
	svc, err := b.Build()
	if err != nil {
		panic(err)
	}
	return svc
}

func (b *AlphaV4) buildScoped(ctx string, reqNames []string) (*Alpha, error) {
	missing := []string{}

	isMissingBeta := b.svc.beta == nil

	check := func(name string, isMissing bool) {
		if isMissing {
			missing = append(missing, name)
		}
	}

	if reqNames == nil {

		check("Beta", isMissingBeta)

	} else {
		for _, n := range reqNames {
			switch n {

			case "Beta":
				check("Beta", isMissingBeta)

			}
		}
	}

	if len(missing) > 0 {
		return nil, fmt.Errorf("%s: wiring incomplete (ctx=%s, missing=%v, spec=%s)",
			"AlphaV4", ctx, missing, "afd262a9627a67551a443862be272716c420f807fa22888c4b36cbe77bd6af93")
	}
	return b.svc, nil
}

func (b *AlphaV4) DoAlpha(
	ctx context.Context,
	req AlphaRequest,
) (AlphaResponse, error) {
	svc, err := b.buildScoped("DoAlpha", []string{
		"Beta",
	})
	if err != nil {
		var zero0 AlphaResponse

		return zero0, err
	}

	return svc.DoAlpha(
		ctx,
		req,
	)
}

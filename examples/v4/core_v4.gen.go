// Code generated by (di v2); DO NOT EDIT.
// Spec: specs/core.inject.json
// Spec-SHA256: 136de190e5d1532fa5e88ecdd68639728f8339845f44eada2b47cf6d89f9fb0f

package v4

import (
	"context"
	"fmt"
	di "github.com/sghaida/odi/di"
	config "github.com/sghaida/odi/examples/v4/config"
	"strings"
)

// CoreV4InjectPolicyOnOverwrite controls behavior when a required dep is injected twice.
// NOTE: generated as a var to allow unit tests to cover all branches.
var CoreV4InjectPolicyOnOverwrite = "error"

// Optional registry keys for CoreV4.
const (
	CoreV4OptionalMetricsKey = "v4.metrics"
	CoreV4OptionalTracerKey  = "v4.tracer"
)

type CoreV4 struct {
	cfg config.Config
	svc *Core

	injected map[string]bool

	// Optional wiring diagnostics (best-effort)
	optionalResolved map[string]string
	optionalMissing  map[string]string
}

// NewCoreV4 creates a new builder/facade.
// You must call Build()/BuildWith()/MustBuild() before calling business methods.
func NewCoreV4(cfg config.Config) *CoreV4 {
	return &CoreV4{
		cfg:              cfg,
		svc:              NewCore(cfg),
		injected:         map[string]bool{},
		optionalResolved: map[string]string{},
		optionalMissing:  map[string]string{},
	}
}

// Clone copies the builder with the current injected state.
// Useful for tests and branching wiring paths.
func (b *CoreV4) Clone() *CoreV4 {
	nb := &CoreV4{
		cfg:              b.cfg,
		svc:              b.svc,
		injected:         map[string]bool{},
		optionalResolved: map[string]string{},
		optionalMissing:  map[string]string{},
	}
	for k, v := range b.injected {
		nb.injected[k] = v
	}
	for k, v := range b.optionalResolved {
		nb.optionalResolved[k] = v
	}
	for k, v := range b.optionalMissing {
		nb.optionalMissing[k] = v
	}
	return nb
}

// Reset discards injected bookkeeping and recreates the underlying implementation.
func (b *CoreV4) Reset() *CoreV4 {
	b.svc = NewCore(b.cfg)
	b.injected = map[string]bool{}
	b.optionalResolved = map[string]string{}
	b.optionalMissing = map[string]string{}
	return b
}

// UnsafeImpl returns the underlying implementation pointer for composition root wiring.
// It must NOT be used to call business methods before Build()/MustBuild().
func (b *CoreV4) UnsafeImpl() *Core { return b.svc }

// Inject allows custom wiring for advanced usage.
// Prefer InjectX methods for required deps.
func (b *CoreV4) Inject(fn func(*Core)) *CoreV4 {
	if fn != nil {
		fn(b.svc)
	}
	return b
}

// TryInjectAlpha injects the required dependency Alpha.
// Unlike InjectAlpha, it returns an error instead of panicking.
func (b *CoreV4) TryInjectAlpha(dep *Alpha) (*CoreV4, error) {
	switch CoreV4InjectPolicyOnOverwrite {
	case "error":
		if b.injected["Alpha"] {
			return nil, fmt.Errorf("CoreV4: duplicate inject Alpha")
		}
	case "ignore":
		if b.injected["Alpha"] {
			return b, nil
		}
	case "overwrite":
		// allow overwriting
	default:
		return nil, fmt.Errorf("CoreV4: invalid injectPolicy.onOverwrite=%s", CoreV4InjectPolicyOnOverwrite)
	}
	b.svc.alpha = dep
	b.injected["Alpha"] = true
	return b, nil
}

// InjectAlpha injects the required dependency Alpha and panics on policy violations.
// Prefer TryInjectAlpha for safer wiring in tests.
func (b *CoreV4) InjectAlpha(dep *Alpha) *CoreV4 {
	nb, err := b.TryInjectAlpha(dep)
	if err != nil {
		panic(err)
	}
	return nb
}

// TryInjectBeta injects the required dependency Beta.
// Unlike InjectBeta, it returns an error instead of panicking.
func (b *CoreV4) TryInjectBeta(dep *Beta) (*CoreV4, error) {
	switch CoreV4InjectPolicyOnOverwrite {
	case "error":
		if b.injected["Beta"] {
			return nil, fmt.Errorf("CoreV4: duplicate inject Beta")
		}
	case "ignore":
		if b.injected["Beta"] {
			return b, nil
		}
	case "overwrite":
		// allow overwriting
	default:
		return nil, fmt.Errorf("CoreV4: invalid injectPolicy.onOverwrite=%s", CoreV4InjectPolicyOnOverwrite)
	}
	b.svc.beta = dep
	b.injected["Beta"] = true
	return b, nil
}

// InjectBeta injects the required dependency Beta and panics on policy violations.
// Prefer TryInjectBeta for safer wiring in tests.
func (b *CoreV4) InjectBeta(dep *Beta) *CoreV4 {
	nb, err := b.TryInjectBeta(dep)
	if err != nil {
		panic(err)
	}
	return nb
}

// Missing returns the list of missing required dependency names at this moment.
// This is useful for debug UX before calling Build().
func (b *CoreV4) Missing() []string {
	missing := []string{}
	if b.svc.alpha == nil {
		missing = append(missing, "Alpha")
	}
	if b.svc.beta == nil {
		missing = append(missing, "Beta")
	}
	return missing
}

// Explain returns a human-friendly summary of the wiring state.
func (b *CoreV4) Explain() string {
	var sb strings.Builder
	m := b.Missing()
	if len(m) == 0 {
		sb.WriteString("required: complete\n")
	} else {
		sb.WriteString(fmt.Sprintf("required: missing=%v\n", m))
	}
	if len(b.optionalResolved) > 0 {
		sb.WriteString("optional: resolved\n")
		for k, v := range b.optionalResolved {
			sb.WriteString(fmt.Sprintf("  - %s => %s\n", k, v))
		}
	}
	if len(b.optionalMissing) > 0 {
		sb.WriteString("optional: missing\n")
		for k, v := range b.optionalMissing {
			sb.WriteString(fmt.Sprintf("  - %s => %s\n", k, v))
		}
	}
	return sb.String()
}

func (b *CoreV4) Build() (*Core, error) {
	return b.buildScoped("Build", nil)
}

// NOTE: Registry.Resolve must be (val any, ok bool, err error)
func (b *CoreV4) BuildWith(reg di.Registry) (*Core, error) {

	if reg != nil {
		// IMPORTANT: declare once; reuse for each optional dep to avoid ":=" redeclare errors.
		var (
			v   any
			ok  bool
			err error
		)

		v, ok, err = reg.Resolve(b.cfg, "v4.metrics")
		if err != nil {
			return nil, fmt.Errorf("CoreV4: optional dep Metrics resolve failed: %w", err)
		}
		if ok {
			casted, ok := v.(Metrics)
			if !ok {
				return nil, fmt.Errorf("CoreV4: optional dep Metrics key=v4.metrics: want Metrics, got %T", v)
			}

			b.svc.metrics = casted

			b.optionalResolved["v4.metrics"] = fmt.Sprintf("%T", v)
		} else {
			def := NoopMetrics{}
			b.svc.metrics = def
			b.optionalMissing["v4.metrics"] = "used defaultExpr"
		}

		v, ok, err = reg.Resolve(b.cfg, "v4.tracer")
		if err != nil {
			return nil, fmt.Errorf("CoreV4: optional dep Tracer resolve failed: %w", err)
		}
		if ok {
			casted, ok := v.(Tracer)
			if !ok {
				return nil, fmt.Errorf("CoreV4: optional dep Tracer key=v4.tracer: want Tracer, got %T", v)
			}

			b.svc.SetTracer(casted)

			b.optionalResolved["v4.tracer"] = fmt.Sprintf("%T", v)
		} else {
			def := NoopTracer{}
			b.svc.SetTracer(def)
			b.optionalMissing["v4.tracer"] = "used defaultExpr"
		}

	}

	return b.buildScoped("BuildWith", nil)
}

func (b *CoreV4) MustBuild() *Core {
	svc, err := b.Build()
	if err != nil {
		panic(err)
	}
	return svc
}

func (b *CoreV4) buildScoped(ctx string, reqNames []string) (*Core, error) {
	missing := []string{}

	isMissingAlpha := b.svc.alpha == nil

	isMissingBeta := b.svc.beta == nil

	check := func(name string, isMissing bool) {
		if isMissing {
			missing = append(missing, name)
		}
	}

	if reqNames == nil {

		check("Alpha", isMissingAlpha)

		check("Beta", isMissingBeta)

	} else {
		for _, n := range reqNames {
			switch n {

			case "Alpha":
				check("Alpha", isMissingAlpha)

			case "Beta":
				check("Beta", isMissingBeta)

			}
		}
	}

	if len(missing) > 0 {
		return nil, fmt.Errorf("%s: wiring incomplete (ctx=%s, missing=%v, spec=%s)",
			"CoreV4", ctx, missing, "136de190e5d1532fa5e88ecdd68639728f8339845f44eada2b47cf6d89f9fb0f")
	}
	return b.svc, nil
}

func (b *CoreV4) Process(
	ctx context.Context,
	req ProcessRequest,
) (ProcessResponse, error) {
	svc, err := b.buildScoped("Process", []string{
		"Alpha",
		"Beta",
	})
	if err != nil {
		var zero0 ProcessResponse

		return zero0, err
	}

	return svc.Process(
		ctx,
		req,
	)
}

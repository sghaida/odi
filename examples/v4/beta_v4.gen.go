// Code generated by (di v2); DO NOT EDIT.
// Spec: specs/beta.inject.json
// Spec-SHA256: 8147bf8aca6e83ef858e201740e050e146b4df41a3081ac4daf0983e038c6962

package v4

import (
	"context"
	"fmt"
	di "github.com/sghaida/odi/di"
	config "github.com/sghaida/odi/examples/v4/config"
	"strings"
)

// BetaV4InjectPolicyOnOverwrite controls behavior when a required dep is injected twice.
// NOTE: generated as a var to allow unit tests to cover all branches.
var BetaV4InjectPolicyOnOverwrite = "error"

type BetaV4 struct {
	cfg config.Config
	svc *Beta

	injected map[string]bool

	// Optional wiring diagnostics (best-effort)
	optionalResolved map[string]string
	optionalMissing  map[string]string
}

// NewBetaV4 creates a new builder/facade.
// You must call Build()/BuildWith()/MustBuild() before calling business methods.
func NewBetaV4(cfg config.Config) *BetaV4 {
	return &BetaV4{
		cfg:              cfg,
		svc:              NewBeta(cfg),
		injected:         map[string]bool{},
		optionalResolved: map[string]string{},
		optionalMissing:  map[string]string{},
	}
}

// Clone copies the builder with the current injected state.
// Useful for tests and branching wiring paths.
func (b *BetaV4) Clone() *BetaV4 {
	nb := &BetaV4{
		cfg:              b.cfg,
		svc:              b.svc,
		injected:         map[string]bool{},
		optionalResolved: map[string]string{},
		optionalMissing:  map[string]string{},
	}
	for k, v := range b.injected {
		nb.injected[k] = v
	}
	for k, v := range b.optionalResolved {
		nb.optionalResolved[k] = v
	}
	for k, v := range b.optionalMissing {
		nb.optionalMissing[k] = v
	}
	return nb
}

// Reset discards injected bookkeeping and recreates the underlying implementation.
func (b *BetaV4) Reset() *BetaV4 {
	b.svc = NewBeta(b.cfg)
	b.injected = map[string]bool{}
	b.optionalResolved = map[string]string{}
	b.optionalMissing = map[string]string{}
	return b
}

// UnsafeImpl returns the underlying implementation pointer for composition root wiring.
// It must NOT be used to call business methods before Build()/MustBuild().
func (b *BetaV4) UnsafeImpl() *Beta { return b.svc }

// Inject allows custom wiring for advanced usage.
// Prefer InjectX methods for required deps.
func (b *BetaV4) Inject(fn func(*Beta)) *BetaV4 {
	if fn != nil {
		fn(b.svc)
	}
	return b
}

// TryInjectAlpha injects the required dependency Alpha.
// Unlike InjectAlpha, it returns an error instead of panicking.
func (b *BetaV4) TryInjectAlpha(dep *Alpha) (*BetaV4, error) {
	switch BetaV4InjectPolicyOnOverwrite {
	case "error":
		if b.injected["Alpha"] {
			return nil, fmt.Errorf("BetaV4: duplicate inject Alpha")
		}
	case "ignore":
		if b.injected["Alpha"] {
			return b, nil
		}
	case "overwrite":
		// allow overwriting
	default:
		return nil, fmt.Errorf("BetaV4: invalid injectPolicy.onOverwrite=%s", BetaV4InjectPolicyOnOverwrite)
	}
	b.svc.alpha = dep
	b.injected["Alpha"] = true
	return b, nil
}

// InjectAlpha injects the required dependency Alpha and panics on policy violations.
// Prefer TryInjectAlpha for safer wiring in tests.
func (b *BetaV4) InjectAlpha(dep *Alpha) *BetaV4 {
	nb, err := b.TryInjectAlpha(dep)
	if err != nil {
		panic(err)
	}
	return nb
}

// Missing returns the list of missing required dependency names at this moment.
// This is useful for debug UX before calling Build().
func (b *BetaV4) Missing() []string {
	missing := []string{}
	if b.svc.alpha == nil {
		missing = append(missing, "Alpha")
	}
	return missing
}

// Explain returns a human-friendly summary of the wiring state.
func (b *BetaV4) Explain() string {
	var sb strings.Builder
	m := b.Missing()
	if len(m) == 0 {
		sb.WriteString("required: complete\n")
	} else {
		sb.WriteString(fmt.Sprintf("required: missing=%v\n", m))
	}
	return sb.String()
}

func (b *BetaV4) Build() (*Beta, error) {
	return b.buildScoped("Build", nil)
}

// NOTE: Registry.Resolve must be (val any, ok bool, err error)
func (b *BetaV4) BuildWith(reg di.Registry) (*Beta, error) {

	return b.buildScoped("BuildWith", nil)
}

func (b *BetaV4) MustBuild() *Beta {
	svc, err := b.Build()
	if err != nil {
		panic(err)
	}
	return svc
}

func (b *BetaV4) buildScoped(ctx string, reqNames []string) (*Beta, error) {
	missing := []string{}

	isMissingAlpha := b.svc.alpha == nil

	check := func(name string, isMissing bool) {
		if isMissing {
			missing = append(missing, name)
		}
	}

	if reqNames == nil {

		check("Alpha", isMissingAlpha)

	} else {
		for _, n := range reqNames {
			switch n {

			case "Alpha":
				check("Alpha", isMissingAlpha)

			}
		}
	}

	if len(missing) > 0 {
		return nil, fmt.Errorf("%s: wiring incomplete (ctx=%s, missing=%v, spec=%s)",
			"BetaV4", ctx, missing, "8147bf8aca6e83ef858e201740e050e146b4df41a3081ac4daf0983e038c6962")
	}
	return b.svc, nil
}

func (b *BetaV4) DoBeta(
	ctx context.Context,
	DoBeta BetaRequest,
) (BetaResponse, error) {
	svc, err := b.buildScoped("DoBeta", []string{
		"Alpha",
	})
	if err != nil {
		var zero0 BetaResponse

		return zero0, err
	}

	return svc.DoBeta(
		ctx,
		DoBeta,
	)
}
